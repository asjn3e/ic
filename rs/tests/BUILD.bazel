load("@aspect_bazel_lib//lib:tar.bzl", "tar")
load("@bazel_skylib//rules:common_settings.bzl", "bool_flag")
load("@bazel_skylib//rules:run_binary.bzl", "run_binary")
load("@rules_distroless//apt:defs.bzl", "dpkg_status")
load("@rules_distroless//distroless:defs.bzl", "passwd")
load("@rules_oci//oci:defs.bzl", "oci_image")
load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
load("//bazel:defs.bzl", "symlink_dir", "symlink_dir_test", "symlink_dirs")
load("//rs/tests:common.bzl", "DEPENDENCIES", "MACRO_DEPENDENCIES")
load(":system_tests.bzl", "foo", "uvm_config_image")

package(default_visibility = ["//rs:system-tests-pkg"])

exports_files([
    "src/memory_safety.wasm",
    "src/message.wasm",
    "src/counter.wat",
])

ALIASES = {
    "//rs/utils": "utils",
}

bool_flag(
    name = "k8s",
    build_setting_default = False,
)

rust_library(
    name = "tests",
    testonly = True,
    srcs = glob(["src/**/*.rs"]),
    aliases = ALIASES,
    compile_data = [
        "//ic-os/components:ic/ic.json5.template",
        "src/memory_safety.wasm",
        "src/counter.wat",
        "src/ledger_tests/transaction_ledger_correctness.wasm",
    ],
    crate_name = "ic_tests",
    proc_macro_deps = MACRO_DEPENDENCIES,
    target_compatible_with = ["@platforms//os:linux"],  # requires libssh that does not build on Mac OS
    deps = DEPENDENCIES,
)

PACKAGES = [
    "@focal//ca-certificates/amd64",
    "@focal//bash/amd64",
    "@focal//coreutils/amd64",
    "@focal//gawk/amd64",
    "@focal//curl/amd64",  # TODO: remove
    "@focal//dosfstools/amd64",
    "@focal//libssl1.1/amd64",
    "@focal//libunwind8/amd64",
    "@focal//mtools/amd64",
    "@focal//openssh-client/amd64",
    "@focal//rsync/amd64",
    "@focal//gzip/amd64",
    "@focal//zstd/amd64",
]

tar(
    name = "sh",
    mtree = [
        # needed as dpkg assumes sh is installed in a typical debian installation.
        "./bin/sh type=link link=/bin/bash",
    ],
)

tar(
    name = "mkfsvfat",
    mtree = [
        # needed as dpkg assumes sh is installed in a typical debian installation.
        "./bin/mkfs.vfat type=link link=/sbin/mkfs.vfat",
    ],
)

tar(
    name = "awk",
    mtree = [
        # needed as dpkg assumes sh is installed in a typical debian installation.
        "./bin/awk type=link link=/usr/bin/gawk",
    ],
)

# Creates /var/lib/dpkg/status with installed package information.
dpkg_status(
    name = "dpkg_status",
    controls = [
        "%s:control" % package
        for package in PACKAGES
    ],
)

passwd(
    name = "passwd",
    entries = [
        dict(
            gecos = ["root"],
            gid = 0,
            home = "/root",
            shell = "/usr/bin/bash",
            uid = 0,
            username = "root",
        ),
    ],
)

oci_image(
    name = "ubuntu_test_runtime_image_src",
    architecture = "amd64",
    os = "linux",
    target_compatible_with = [
        "@platforms//os:linux",
    ],
    tars = [
        ":dpkg_status",
        ":passwd",  # needed because we ssh in

        # symlinks
        ":awk",
        ":mkfsvfat",
        ":sh",
    ] + PACKAGES,
)

# TODO: why do we need to load this? can't we use rules_oci to build?
foo(
    image = ":ubuntu_test_runtime_image_src",
    repo_tags = ["ubuntu_test_runtime:image"],
    tarname = "ubuntu_test_runtime.tar",
)

uvm_config_image(
    name = "colocate_uvm_config_image",
    srcs = [
        ":ubuntu_test_runtime.tar",
        "//rs/tests:activate-systest-uvm-config",
    ],
    remap_paths = {
        "activate-systest-uvm-config": "activate",
    },
    tags = ["manual"],  # this target will be built if required as a dependency of another target
)

rust_test(
    name = "tests_test",
    aliases = ALIASES,
    crate = ":tests",
    proc_macro_deps = MACRO_DEPENDENCIES,
    target_compatible_with = ["@platforms//os:linux"],  # requires libssh that does not build on Mac OS
    deps = DEPENDENCIES,
)

exports_files([
    "create-universal-vm-config-image.sh",
])

filegroup(
    name = "grafana_dashboards",
    srcs = glob(["dashboards/**/*"]),
)

symlink_dir(
    name = "recovery/binaries",
    testonly = True,
    targets = {
        "//rs/registry/admin:ic-admin": "ic-admin",
        "//rs/state_tool:state-tool": "state-tool",
        "//rs/canister_sandbox:compiler_sandbox": "compiler_sandbox",
        "//rs/canister_sandbox:sandbox_launcher": "sandbox_launcher",
        "//rs/canister_sandbox:canister_sandbox": "canister_sandbox",
        "@crate_index//:ic-wasm__ic-wasm": "ic-wasm",
    },
)

symlink_dir(
    name = "backup/binaries",
    testonly = True,
    targets = {
        "//rs/backup:ic-backup": "ic-backup",
        "//rs/replay:ic-replay": "ic-replay",
        "//rs/canister_sandbox:compiler_sandbox": "compiler_sandbox",
        "//rs/canister_sandbox:sandbox_launcher": "sandbox_launcher",
        "//rs/canister_sandbox:canister_sandbox": "canister_sandbox",
    },
)

symlink_dir_test(
    name = "cup_compatibility/binaries",
    targets = {
        "//rs/types/types:types_test": "types_test",
    },
)

exports_files([
    "src/orchestrator/orchestrator_universal_vm_activation.sh",
])

foo(
    image = "@static-file-server",
    repo_tags = ["static-file-server:image"],  #TODO: change this
    tarname = "static-file-server.tar",
)

exports_files([
    "src/btc_integration/bitcoin.conf",
    "src/btc_integration/btc_activate.sh",
])

uvm_config_image(
    name = "btc_uvm_config_image",
    srcs = [
        ":bitcoind.tar",
        ":src/btc_integration/bitcoin.conf",
        ":src/btc_integration/btc_activate.sh",
    ],
    remap_paths = {
        "btc_activate.sh": "activate",
    },
    tags = ["manual"],  # this target will be built if required as a dependency of another target
)

exports_files([
    "src/jaeger/jaeger_activate.sh",
])

uvm_config_image(
    name = "jaeger_uvm_config_image",
    srcs = [
        # ":src/btc_integration/bitcoin.conf",
        ":src/jaeger/jaeger_activate.sh",
        ":jaeger_image",
    ],
    remap_paths = {
        "jaeger_activate.sh": "activate",
    },
    tags = ["manual"],  # this target will be built if required as a dependency of another target
)

filegroup(
    name = "rosetta_workspace",
    srcs = glob(["rosetta_workspace/*"]),
)

exports_files([
    "src/canister_http/universal_vm_activation.sh",
])

run_binary(
    name = "wabt-tests",
    outs = [
        "custom_section_name_with_spaces.wasm",
        "duplicate_custom_section.wasm",
        "empty_custom_section_name.wasm",
        "empty_query_name.wasm",
        "invalid_canister_composite_query_cq_reta.wasm",
        "invalid_canister_composite_query_cq_retb.wasm",
        "invalid_canister_export.wasm",
        "invalid_canister_global_timer_reta.wasm",
        "invalid_canister_global_timer_retb.wasm",
        "invalid_canister_heartbeat_reta.wasm",
        "invalid_canister_heartbeat_retb.wasm",
        "invalid_canister_init_reta.wasm",
        "invalid_canister_init_retb.wasm",
        "invalid_canister_inspect_message_reta.wasm",
        "invalid_canister_inspect_message_retb.wasm",
        "invalid_canister_post_upgrade_reta.wasm",
        "invalid_canister_post_upgrade_retb.wasm",
        "invalid_canister_pre_upgrade_reta.wasm",
        "invalid_canister_pre_upgrade_retb.wasm",
        "invalid_canister_query_que_reta.wasm",
        "invalid_canister_query_que_retb.wasm",
        "invalid_canister_update_upd_reta.wasm",
        "invalid_canister_update_upd_retb.wasm",
        "invalid_custom_section.wasm",
        "invalid_empty_custom_section_name.wasm",
        "invalid_empty_query_name.wasm",
        "invalid_import.wasm",
        "large_custom_sections.wasm",
        "long_exported_function_names.wasm",
        "many_custom_sections.wasm",
        "many_exports.wasm",
        "many_functions.wasm",
        "many_globals.wasm",
        "name_clash_query_composite_query.wasm",
        "name_clash_update_composite_query.wasm",
        "name_clash_update_query.wasm",
        "no_start.wasm",
        "query_name_with_spaces.wasm",
        "start.wasm",
        "too_large_custom_sections.wasm",
        "too_long_exported_function_names.wasm",
        "too_many_custom_sections.wasm",
        "too_many_exports.wasm",
        "too_many_functions.wasm",
        "too_many_globals.wasm",
        "valid_import.wasm",
    ],
    args = ["$(location valid_import.wasm)"],  # passing location of an arbitrary output file is a hack, see https://github.com/bazelbuild/bazel-skylib/blob/288731ef9f7f688932bd50e704a91a45ec185f9b/rules/run_binary.bzl#L29
    target_compatible_with = ["@platforms//os:linux"],
    tool = "//rs/tests/testing_verification/wabt-tests:generator",
)

symlink_dirs(
    name = "ic-hs",
    target_compatible_with = ["@platforms//os:linux"],
    targets = {
        "//hs/spec_compliance:ic-ref-test": "bin",
        "//rs/universal_canister/impl:universal_canister.wasm.gz": "test-data",
        "//rs/tests:wabt-tests": "test-data",
    },
    visibility = [
        "//rs:system-tests-pkg",
        "//rs/pocket_ic_server:__pkg__",
    ],
)

foo(
    image = "@jaeger",
    repo_tags = ["jaegertracing/all-in-one:1.58"],  # TODO: fix this
    tarname = "jaeger.tar",
)

#oci_load(
#    name = "jaeger_image_load",
#    image = "@jaeger",
#    repo_tags = ["jaegertracing/all-in-one:1.58"],  # TODO: fix this
#    target_compatible_with = [
#        "@platforms//os:linux",
#    ],
#)
#
#filegroup(
#    name = "jaeger_image.tar",
#    srcs = [":jaeger_image_load"],
#    output_group = "tarball",
#    target_compatible_with = [
#        "@platforms//os:linux",
#    ],
#)
#
#copy_file(
#    name = "jaeger_image",
#    src = ":jaeger_image.tar",
#    out = "jaeger.tar",  # TODO: check jaeger_activate changes
#    target_compatible_with = [
#        "@platforms//os:linux",
#    ],
#)

#oci_load(
#    name = "bitcoind_image",
#    image = "@bitcoind",
#    repo_tags = ["bitcoind:pinned"],
#    target_compatible_with = [
#        "@platforms//os:linux",
#    ],
#)
#
#filegroup(
#    name = "bitcoind_tarballdir",
#    srcs = [":bitcoind_image"],
#    output_group = "tarball",
#    target_compatible_with = [
#        "@platforms//os:linux",
#    ],
#)
#
#copy_file(
#    name = "bitcoind_tar",
#    src = ":bitcoind_tarballdir",
#    out = "bitcoind.tar",  # TODO: btc activate expects this (*sigh*)
#    target_compatible_with = [
#        "@platforms//os:linux",
#    ],
#)

# TODO: btc activate expects this (*sigh*)
foo(
    image = "@bitcoind",
    repo_tags = ["bitcoind:pinned"],
    tarname = "bitcoind.tar",
)

foo(
    image = "@coredns",
    repo_tags = ["coredns:latest"],
    tarname = "coredns.tar",
)

foo(
    image = "@pebble",
    repo_tags = ["pebble:latest"],
    tarname = "pebble.tar",
)

#oci_load(
#    name = "pebble_image",
#    image = "@pebble",
#    repo_tags = [ "pebble:latest" ],
#    target_compatible_with = [
#        "@platforms//os:linux",
#    ],
#)
#
#filegroup(
#    name = "pebble_tarballdir",
#    srcs = [":pebble_image"],
#    output_group = "tarball",
#
#)
#
#copy_file(
#    name = "pebble_tar",
#    src = ":pebble_tarballdir",
#    out = "pebble.tar",
#    target_compatible_with = [
#        "@platforms//os:linux",
#    ],
#)

foo(
    image = "@python3",
    repo_tags = ["python3:latest"],
    tarname = "python3.tar",
)

#oci_load(
#    name = "python3_image",
#    image = "@python3",
#    repo_tags = [ "python3:latest" ], # TODO: must have tag
#    target_compatible_with = [
#        "@platforms//os:linux",
#    ],
#)
#
#filegroup(
#    name = "python3_tarballdir",
#    srcs = [":python3_image"],
#    output_group = "tarball",
#    target_compatible_with = [
#        "@platforms//os:linux",
#    ],
#)
#
#copy_file(
#    name = "python3_tar",
#    src = ":python3_tarballdir",
#    out = "python3.tar",
#    target_compatible_with = [
#        "@platforms//os:linux",
#    ],
#)

foo(
    image = "@alpine_openssl",
    repo_tags = ["openssl:latest"],
    tarname = "openssl.tar",
)

#oci_load(
#    name = "openssl_image",
#    image = "@alpine_openssl",
#    repo_tags = [ "openssl:latest" ],
#    target_compatible_with = [
#        "@platforms//os:linux",
#    ],
#)
#
#filegroup(
#    name = "openssl_tarballdir",
#    srcs = [":openssl_image"],
#    output_group = "tarball",
#    target_compatible_with = [
#        "@platforms//os:linux",
#    ],
#)
#
#copy_file(
#    name = "openssl_tar",
#    src = ":openssl_tarballdir",
#    out = "openssl.tar",
#    target_compatible_with = [
#        "@platforms//os:linux",
#    ],
#)

uvm_config_image(
    name = "custom_domains_uvm_config_image",
    srcs = [
        # Docker images
        ":coredns_tar",
        ":openssl_tar",
        ":pebble_tar",
        ":python3_tar",

        # Assets
        ":src/custom_domains_integration/activate.sh",
        ":src/custom_domains_integration/pebble_cache.py",
        ":src/custom_domains_integration/cloudflare_api.py",
    ],
    remap_paths = {"activate.sh": "activate"},
    tags = ["manual"],  # this target will be built if required as a dependency of another target
)
